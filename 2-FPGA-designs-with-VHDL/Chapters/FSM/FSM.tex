\chapter{Finite state machines} \label{ch:FSM}
\chapterquote{People must give and then receive. First give and then you will have all. But instead, people want to first have all and then think of giving. This is not the right way.}{Meher Baba}

\graphicspath{{Chapters/FSM/Figures/}}
\lstinputpath{Codes-VHDL/Chapter-Finite-state-machines/VHDLCodes} %path is defined in mypreamble


%\input{Chapters/FSM/Introduction}

\section{Introduction}
In previous chapters, we saw various examples of the combinational circuits and sequential circuits. In combinational circuits, the output depends on the current values of inputs only; whereas in sequential circuits, the output depends on the current values of the inputs along with the previously stored information. In the other words, storage elements, e.g. flip flogs or registers, are required for sequential circuits. The information stored in these elements can be seen as the states of the system. If a system transits between finite number of such internal states, then finite state machines (FSM) can be used to design the system. The FSM designed can be classified as `Moore machine' and `Mealy machine' which are discussed in this chapter.  

This chapter is organized as follows. First, Moore and Mealy designs are discussed in Section \ref{sec:MealyMooreDesign}. Then an example of these designs are shown in Section \ref{sec:FSMExample}. After this the sequential circuit designs using FSM are discussed in details. 

\section{Comparison: Mealy and Moore designs}\label{sec:MealyMooreDesign}
FMS design is known as Moore design if the output of the system depends only on the states (see Fig. \ref{fig:MooreEdgeDetector}); whereas it is known as Mealy design if the output depends on the states and external inputs (see Fig. \ref{fig:MealyEdgeDetector}). Further, a system may contain both types of designs simultaneously. Following are the few differences in Mealy and Moore design, 


\begin{enumerate}
	\item In Mealy machine, the output is available as soon as the input is changed, whereas in Moore machine, the output is available after 1 clock cycle as shown in Fig. \ref{fig:edgeDetectorWave}.
	
	\item Mealy machine requires fewer number of states as compared to Moore machine as shown in Listing \ref{vhdl:edgeDetector}. 
	
	\item Mealy machines are good for synchronous systems as discussed in the chapter, but careful design is required for asynchronous systems. Therefore, Mealy machine can be complex as compare to Moore machine. 
\end{enumerate}

\section{Example: Rising edge detector} \label{sec:FSMExample}
Rising edge detector generates a tick for the duration of one clock cycle, whenever input signal changes from 0 to 1. In this section, state diagrams of rising edge detector for Mealy and Moore designs are shown. Then rising edge detector is implemented using VHDL code. Also, outputs of these two designs are compared. 

\subsection{State diagrams: Mealy and Moore design}
Fig. \ref{fig:MealyEdgeDetector} and \ref{fig:MooreEdgeDetector} are the state diagrams for Mealy and Moore designs respectively. In Fig. \ref{fig:MealyEdgeDetector}, the output of the system is set to 1, whenever the system is in the state `zero' and value of the input signal `level' is 1; i.e. output depends on both the state and the input. Whereas in Fig. \ref{fig:MooreEdgeDetector}, the output is set to 1 whenever the system is in the state `edge' i.e. output depends only on the state of the system. 

\begin{figure}[h!]
	\centering
	\begin{subfigure}[t]{0.5\textwidth}
		\centering
		\includegraphics[scale=1]{MealyEdgeDetector}
		\caption{Mealy Design}
		\label{fig:MealyEdgeDetector}
	\end{subfigure}%
	\begin{subfigure}[t]{0.5\textwidth}
		\centering
		\includegraphics[scale=0.8]{MooreEdgeDetector}
		\caption{Moore Design}
		\label{fig:MooreEdgeDetector}
	\end{subfigure}
	
	\caption{State diagrams for Edge detector }
\end{figure}


%\begin{figure}[!h]
%	\centering
%	\includegraphics[scale=1]{MealyEdgeDetector}
%	\caption{Edge Detector with Mealy Design}
%	\label{fig:MealyEdgeDetector}
%\end{figure}
%
%\begin{figure}[!h]
%	\centering
%	\includegraphics[scale=0.8]{MooreEdgeDetector}
%	\caption{Edge Detector with Moore Design}
%	\label{fig:MooreEdgeDetector}
%\end{figure}


\subsection{Implementation}
Both Mealy and Moore designs are implemented in Listing \ref{vhdl:edgeDetector}. The listing can be seen as two parts i.e. Mealy design (Lines 36-54) and Moore design (Lines 56-80). Please read the comments for complete understanding of the code. The simulation waveforms i.e. Fig. \ref{fig:edgeDetectorWave} are discussed in next section. 
\lstinputlisting[
language = Vhdl,
caption    = {Edge detector: Mealy and Moore designs},
label      = {vhdl:edgeDetector}
]{edgeDetector.vhd}

\subsection{Outputs comparison}

In Fig. \ref{fig:edgeDetectorWave}, it can be seen that output-tick of Mealy detector is generated as soon as the `level' goes to 1, whereas Moore design generate the tick after 1 clock cycle. These two ticks are shown with the help of the two red cursors in the figure. Since, output of Mealy design is immediately available therefore it is preferred for synchronous designs. 

\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{edgeDetectorWave}
	\caption{Simulation waveforms of rising edge detector in Listing \ref{vhdl:edgeDetector}}
	\label{fig:edgeDetectorWave}
\end{figure}

\subsection{Visual verification}
Listing \ref{vhdl:edgeDetector_VisualTest} can be used to verify the results on the FPGA board. Here, clock with 1 Hz frequency is used in line 19, which is defined in Listing \ref{vhdl:clockTick}. After loading the design on FPGA board, we can observe on LEDs that the output of Moore design displayed after  Mealy design, with a delay of 1 second.  

\lstinputlisting[
language = Vhdl,
caption    = {Visual verification of edge detector},
label      = {vhdl:edgeDetector_VisualTest}
]{edgeDetector_VisualTest.vhd}

\section{Synchronous and asynchronous reset}

\section{Glitches}
Glitches are the short duration pulses which are generated in the combinational circuits. These are generated when more than two inputs change their values simultaneously. Glitches can be categorized as `static glitches' and `dynamic glitches'. Static glitches are further divided into two groups i.e. `static-0' and `static-1'. `Static-0' glitch is the glitch which occurs in logic `0' signal i.e. \textbf{one short pulse} `high-pulse (logic-1)' appears in logic-0 signal (and the signal settles down). Dynamic glitch is the glitch in which \textbf{multiple short pulses} appear before the signal settles down. 

\begin{noNumBox}
 Most of the times, the glitches are not the problem in the design. Glitches create problem when it occur in the outputs, which are used as clock for the other circuits. In this case, glitches will trigger the next circuits, which will result in incorrect outputs. In such cases, it is very important to remove these glitches. In this section, the glitches are shown for three cases. Since, clocks are used in synchronous designs, therefore Section \ref{sec:glitchInsSync} is of our main interest.
 \end{noNumBox} 
  
\subsection{Combinational design in asynchronous circuit}
Table \ref{tbl:glitch_table} shows the truth-table for $2 \times 1$ multiplexer and corresponding Karnaugh map is shown in Fig. \ref{fig:glitch_sol}. Note that, the glitches occurs in the circuit, when we exclude the `red part' of the solution from the Fig. \ref{fig:glitch_sol}, which results in minimum-gate solution, but at the same time the solution is disjoint. To remove the glitch, we can add the prime-implicant in red-part as well. This solution is good, if there are few such gates are required; however if the number of inputs are very high, whose values are changing simultaneously then this solution is not practical, as we need to add large number of gates.

\begin{table}[!h]
	\centering
	\includegraphics[scale = 1]{glitch_table}
	\caption{Truth table of $2 \times 1$ Multiplexer}
	\label{tbl:glitch_table}
\end{table}

\begin{figure}[!h]
	\centering
	\includegraphics[scale = 1]{glitch_sol}
	\caption{Reason for glitches and solution}
	\label{fig:glitch_sol}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{glitches}
	\caption{Glitches in design in Listing \ref{vhdl:glitchEx}}
	\label{fig:glitches}
\end{figure}

\lstinputlisting[
language = Vhdl,
caption    = {Glitches in multiplexer},
label      = {vhdl:glitchEx}
]{glitchEx.vhd}

\subsection{Unfixable Glitch}
Listing \ref{vhdl:manchester_code} is another example of glitches in the design as shown in Fig. \ref{fig:manchesterGlitch}. Here, glitches are continuous i.e. these are occurring at every change in signal `din'. Such glitches are removed by using D-flip-flop as shown in Section \ref{sec:glitchInsSync}. \textbf{Since the output of Manchester code depends on both edges of clock (i.e. half of the output changes on $+ve$ edge and other half changes at $-ve$ edge), therefore such glitches are unfixable; as in VHDL both edges can not be connected to one D flip flop. However, the simulation can be performed with both edges connected to D flip flop as shown in Listing \ref{vhdl:manchester_code2}; where glitches are removed using D flip flop.}

\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{manchesterGlitch}
	\caption{Glitches in Listing \ref{vhdl:manchester_code}}
	\label{fig:manchesterGlitch}
\end{figure}

\lstinputlisting[
language = Vhdl,
caption    = {Glitches in Manchester coding},
label      = {vhdl:manchester_code}
]{manchester_code.vhd}

\lstinputlisting[
language = Vhdl,
caption    = {Non-synthesizable solution for removing glitches},
label      = {vhdl:manchester_code2}
]{manchester_code2.vhd}

\subsection{Combinational design in synchronous circuit}\label{sec:glitchInsSync}
Combination designs in sequential circuits were discussed in Fig. \ref{fig:combSeqBlock}. The output of these combination designs can depend on states only, or on the states along with external inputs. The former is known as Moore design and latter is known as Mealy design as discussed in Section \ref{sec:MealyMooreDesign}. Since, the sequential designs are sensitive to edge of the clock, therefore the glitches can occur only at the edge of the clock. Hence, the glitches at the edge can be removed by sending the output signal through the D flip flop, as shown in Fig. \ref{fig:combSeqBlockGlitchFree}. Various VHDL templates for sequential designs are shown in Section \ref{sec:MooreTemplates} and \ref{sec:MealyTemplates}. 

\begin{figure}[!h]
	\centering
	\includegraphics[scale = 0.8]{combSeqBlockGlitchFree}
	\caption{Glitch-free sequential design using D flip flop}
	\label{fig:combSeqBlockGlitchFree}
\end{figure}


\section{Moore architecture and VHDL templates} \label{sec:MooreTemplates}
\subsection{Regular machine}
\lstinputlisting[
language = Vhdl,
caption    = {VHDL template for regular Moore FSM : separate `next\_state' and `output' logic},
label      = {vhdl:moore_regular_template}
]{moore_regular_template.vhd}

\lstinputlisting[
language = Vhdl,
caption    = {VHDL template for regular Moore FSM : combined `next\_state' and `output' logic},
label      = {vhdl:moore_regular_template2}
]{moore_regular_template2.vhd}

\subsection{Timed machine}
\subsection{Recursive machine}

\section{Mealy architecture and VHDL templates} \label{sec:MealyTemplates}
\subsection{Regular machine}

\lstinputlisting[
language = Vhdl,
caption    = {VHDL template for regular Mealy FSM : combined `next\_state' and `output' logic},
label      = {vhdl:mealy_regular_template}
]{mealy_regular_template.vhd}


\subsection{Timed machine}
\subsection{Recursive machine}


\section{When to use FSM design}
We saw in previous sections that, once we have the state diagram for the FSM design, then the VHDL design is a straightforward process. But, it is important to understand the correct conditions for using the FSM, otherwise the circuit will become complicated unnecessary. 

\begin{enumerate}
	\item We should not use the FSM diagram, if there is only `one loop' with `zero or one control input'. `Counter' is a good example for this. A 10-bit counter has 10 states with no control input (i.e. it is free running counter). This can be easily implemented without using FSM as shown in Listing \ref{vhdl:binaryCounter}. If we implement it with FSM, then we need 10 states; and the code and corresponding design will become very large. 
	
	\item If required, then FSM can be use for `one loop' with `two or more control inputs'. 
	
	\item FSM design should be used in the cases where there are very large number of loops (especially connected loops) along with two or more controlling inputs. 
	
\end{enumerate}
\section{Conclusion}
In this chapter, Mealy and Moore designs are discussed. Also, `edge detector' is implemented using Mealy and Moore designs. This example shows that Mealy design requires fewer states than Moore design. Further, Mealy design generates the output tick as soon as the rising edge is detected; whereas Moore design generates the output tick after a delay of one clock cycle. Therefore, Mealy designs are preferred for synchronous designs. 