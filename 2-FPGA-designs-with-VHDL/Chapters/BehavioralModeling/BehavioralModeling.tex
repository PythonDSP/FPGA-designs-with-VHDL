\chapter{Behavioral Modeling} \label{ch:behavioralModeling}
\chapterquote{People must give and then receive. First give and then you will have all. But instead, people want to first have all and then think of giving. This is not the right way.}{Meher Baba}

\graphicspath{{Chapters/BehavioralModeling/Figures/}}
\lstinputpath{Codes-VHDL/Chapter-BehavioralModeling/VHDLCodes} %path is defined in mypreamble


%\input{Chapters/BehavioralModeling/Introduction}

\section{Introduction}
In Chapter \ref{ch:OverView}, 2-bit comparator is designed using behavior modeling. In that chapter, `if' keyword was used in the `process' statement block. This chapter presents some more such keywords. 

\section{Process block}
All the statements inside the process block execute sequentially. Further, if the architecture contains more than one process block, then all the process blocks execute in parallel, i.e. process blocks are the concurrent blocks. Also, if a signal is assigned values multiple times, then only last assignments will be considered as shown in Listing \ref{vhdl:multipleAssgEx}. In the listing, value to port `z' is assigned at Lines 19 and 21. In this case, last assignment will be considered i.e. `and' gate will implemented by Line 21, as shown in Fig. \ref{fig:multipleAssgEx}

\lstinputlisting[
language = Vhdl,
caption    = {Multiple assignments to same signal},
label      = {vhdl:multipleAssgEx}
]{multipleAssgEx.vhd}

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{multipleAssgEx}
	\caption{Design generated by Listing \ref{vhdl:multipleAssgEx}}
	\label{fig:multipleAssgEx}
\end{figure}

\begin{noNumBox}
	Note :
	\begin{enumerate}
		\item If values are assigned to a signal multiple times, then only last assignment will be considered in the `sequential design (Listing \ref{vhdl:multipleAssgEx})', whereas error will be generated for `concurrent design (Listing \ref{vhdl:deltaDelayEx})'. 
		\item We can write the complete design using sequential programming, but this may result in very complex hardware design, or to the design which can not be synthesized at all. The best way of designing is to make small units using behavioral and dataflow modeling, and then use the structural modeling style to create the large system. 
	\end{enumerate}
\end{noNumBox}

\section{If-else statement}
In this section, 4$\times$1 multiplexed is designed using If-else statement. We already see the working of `if' statement in Chapter \ref{ch:OverView}. In lines of 17-27 of Listing \ref{vhdl:ifEx}, `elsif' and `else' are added to `if' statement. Note that, If-else block can contain multiple `elsif' statements between one `if' and one `else' statement. Further, `null' is added in line 26 of Listing \ref{vhdl:ifEx}, whose function is same as `unaffected' in concurrent signal assignment as shown in Listing \ref{vhdl:multiplexerVhdl}. Fig. \ref{fig:ifExWave} shows the waveform generated by Modelsim for Listing \ref{vhdl:ifEx}. 

\begin{noNumBox}
	Note : 
	\begin{enumerate}
		\item The `multiplexer design' in Fig. \ref{fig:ifEx} (generated by if-else in Listing \ref{vhdl:ifEx}) is exactly same as the design in Fig. \ref{fig:multiplexerEx} (generated by when-else in Listing \ref{vhdl:multiplexerEx}).  
		
		\item Further, in Section \ref{sec:concurrentSeq}, it is said that the `combinational logic can be implemented using both the concurrent statements and the sequential statements. Note that, the multiplexer is the `combinational design' as the output depends only on current input values. And it implemented using `concurrent statements' and `sequential statements' in Listing \ref{vhdl:multiplexerEx} and Listing \ref{vhdl:ifEx} respectively. 
	\end{enumerate}
\end{noNumBox}
\lstinputlisting[
language = Vhdl,
caption    = {Multiplexer using if statement},
label      = {vhdl:ifEx}
]{ifEx.vhd}
\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{ifEx}
	\caption{Multiplexer using if statement, Listing \ref{vhdl:ifEx}}
	\label{fig:ifEx}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[scale=1]{ifExWave}
	\caption{Waveforms of Listing \ref{vhdl:ifEx} and \ref{vhdl:caseEx}}
	\label{fig:ifExWave}
\end{figure}


\section{Case statement}
Case statement is shown in lines 17-28 of Listing \ref{vhdl:caseEx}. `s' is defined in case statement at line 17; whose value is checked using `when' keyword at lines 18 and 20 etc. The value of `y' depends on the value of `s' e.g. if `s' is ``01'', then line 20 will be true, hence value of `i1' will be assigned to `y'. 

\begin{noNumBox}
	Note that the `multiplexer design' in Fig. \ref{fig:caseEx} (generated by case in Listing \ref{vhdl:caseEx}) is exactly same as the design in Fig. \ref{fig:multiplexerVhdl} (generated by with-select in Listing \ref{vhdl:multiplexerVhdl}). 
\end{noNumBox}


\lstinputlisting[
language = Vhdl,
caption    = {Multiplexer using case statement},
label      = {vhdl:caseEx}
]{caseEx.vhd}
\begin{figure}
	\centering
	\includegraphics[scale=0.4]{caseEx}
	\caption{Multiplexer using case statement, Listing \ref{vhdl:caseEx}}
	\label{fig:caseEx}
\end{figure}

\section{Wait statement}
`Wait statement' is used to hold the system for certain time duration. It can be used in three different ways as shown below, 

\begin{enumerate}
	\item \textbf{wait until} : It is \textbf{synthesizable} statement and holds the system until the defined condition is met e.g. ``wait until clk = '1''' will hold the system until clk is `1'. 
	
	\item \textbf{wait on} : It is \textbf{synthesizable} statement and holds the system until the defined signal is changed e.g. `wait on clk' will hold the system until clk changes it's value i.e. `0' to `1' or vice-versa.
	
	\item \textbf{wait for} : It is \textbf{not synthesizable} and holds the system for the defined timed e.g. `wait for 20ns' will hold the system for 20 ns. This is used with testbenches as shown in Chapter \ref{ch:Testbench}.
\end{enumerate}

\section{Problem with Loops}

VHDL provides two loop statements i.e. `for' loop and `while' loop'. These loops are very different from software loops. Suppose `for i = 1 to N' is a loop, then, in software `i' will be assigned one value at a time i.e. first i=1, then next cycle i=2 and so on. Whereas in VHDL, N logic will be implement for this loop, which will execute in parallel. Also, in software, `N' cycles are required to complete the loop, whereas in VHDL the loop will execute in one cycle. 
\begin{noNumBox}
	As loops implement the design-units multiple times, therefore design may become large and sometimes can not be synthesized as well. If we do not want to execute everything in one cycle (which is almost always the case), then loops can be replaced by `case' statements and `conditional' statements as shown in section \ref{sec:ifLoop}. Further, due to these reasons, we do not use loops for the design. Lastly, the loops can be extremely useful in testbences, when we want to iterate through all the test-data which is shown in Listing \ref{vhdl:half_adder_lookup_tb.vhd}.  
\end{noNumBox}   

\section{Loop using `if' statement}\label{sec:ifLoop}
In Listing \ref{vhdl:ifLoop}, a loop is created using `if' statement, which counts the number upto input `x'. 

\begin{explanation}[Listing \ref{vhdl:ifLoop}]
	In the listing, two `process' blocks are used i.e. at lines 20 and 31. The process at line 20 checks whether the signal `count' value is `less or equal' to input x (line 22), and sets the currentState to `continueState'; otherwise if count is greater than the input x, then currentState is set to `stopState'.
	
	Then next process statement (line 31), increase the `count' by 1, if currentState is `continueState'; otherwise count is set to 0 for stopState. Finally count is displayed at the output through line 39. In this way, we can implement the loops using process statements. 
	
	Fig. \ref{fig:ifLoop} shows the loop generated by the listing with generic value N=1. Further,  Fig. \ref{fig:ifLoopWave} shows the count-waveforms generated by the listing with generic value N = 3.
	
	\textbf{Sensitivity list of the process block should be implemented carefully. For example, if we add `count' in the sensitivity list at line 31 of Listing  \ref{vhdl:ifLoop}, then the process block will execute infinite times. This will occur because the process block execute whenever there is any event in the signals in the sensitivity list; therefore any change in `count' will execute the block, and then this block will change the `count' value through line 34. Since `count' value is changed, therefore process block will execute again, and the loop will never exit.}
	
\end{explanation}

\lstinputlisting[
language = Vhdl,
caption    = {Loop using `if' statement},
label      = {vhdl:ifLoop}
]{ifLoop.vhd}
\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{ifLoop}
	\caption{Loop using `if' statement, Listing \ref{vhdl:ifLoop} with N = 1}
	\label{fig:ifLoop}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{ifLoopWave}
	\caption{Loop using `if' statement, Listing \ref{vhdl:ifLoop} with N = 3}
	\label{fig:ifLoopWave}
\end{figure}

\begin{noNumBox}
	Note that, the design in Listing \ref{vhdl:ifLoop} is not good because of following reasons,
	\begin{enumerate}		
		\item First, the clock is used in the sensitive list, therefore it may arise race-around condition in the system. To avoid it, the system should be sensitive to only edge of the clock (i.e. positive and negative) , which is discussed in Listing \ref{vhdl:BasicDFF} using `event' keyword.
		
		\item Secondly, the process statement in Line 31, does not required the `clk' in the sensitive list. In Fig. \ref{fig:combSeqBlock}, we saw that the sequential designs contain both `combinational logic' and `sequential logic'; also the figure shows that the `clock' is required  only for `sequential logics'. But in the current design, we used clock in both `combinational logic' and `sequential logic'. Detailed discussion about FSM designs are in Chapter \ref{ch:FSM}, where such issues are raised for careful designs.  
	\end{enumerate}
	
\end{noNumBox}

\section{Unintentional memories in combinational designs}
In previous sections, we saw various statements which can be used within the process-block. Also, in Section \ref{sec:combSeqCircuit}, we discussed that the combinational designs do not have memories. Note that, processes are very easy to implement, but careful design is required, otherwise unintended memories (latches) or internal states (via feedback paths) may be created in combination designs, which is not desirable. This section shows one example of `unintentional latches' along with the precautions to avoid such errors. 

Listing \ref{vhdl:latchEx} assign the values to `large' and `small' based on the values of `a' and `b'. The design generated by the listing is shown in Fig. \ref{fig:latchEx}. Note that two latches are created in the design. Latches are introduced in the circuit, because we did not define the complete set of outputs in the conditions, e.g. we did no specify the value of `small' when `a $>$ b' at Line 17. Therefore, a latch is created to store the previous value of `small' for this condition. 

\lstinputlisting[
language = Vhdl,
caption    = {Unintentional latch},
label      = {vhdl:latchEx}
]{latchEx.vhd}

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.8]{latchEx}
	\caption{Latch generated by Listing \ref{vhdl:latchEx}}
	\label{fig:latchEx}
\end{figure}


\begin{noNumBox}
	The latches can be removed by following two simple rules which are applied in Listing \ref{vhdl:latchRemoveEx} and corresponding design in shown in Fig. \ref{fig:latchRemoveEx}, 
	\begin{enumerate}
		\item Include all the input signals related to combinational designs in the sensitivity list of process statement. 
		\item Always define the `else' block in `if statement' and `others' block in `case' statement. 
		\item Assign all outputs inside every block of statements e.g define all outputs inside every `elsif' block of `if-else' statement and inside every  `when' block of `case' statement etc. 
	\end{enumerate}
\end{noNumBox}

\lstinputlisting[
language = Vhdl,
caption    = {Remove unintentional latch},
label      = {vhdl:latchRemoveEx}
]{latchRemoveEx.vhd}

\begin{figure}
	\centering
	\includegraphics[scale=0.8]{latchRemoveEx}
	\caption{Latch removed by Listing \ref{vhdl:latchRemoveEx}}
	\label{fig:latchRemoveEx}
\end{figure}


Another method remove the unintended memories is the use of `default values' as shown in Listing \ref{vhdl:latchRemoveEx2}. Here we can defined, all the outputs at the beginning of the process statement (Lines 18-19). Then, we can overwrite the values in different statements (i.e. using multiple assignments) e.g. value of `large' is modified in Line 21. The design generated by the listing is shown in Fig. \ref{fig:latchRemoveEx2}. 

\begin{noNumBox}
	Note that, `multiple assignments' are error-prone as discussed in Listing \ref{vhdl:multipleAssgEx}. It's use should be limited to `default-value-assignments' only. Do not use it for any other purposes.   
\end{noNumBox}

\begin{figure}
	\centering
	\includegraphics[scale=0.8]{latchRemoveEx2}
	\caption{Latch removed by default-value-assignments in Listing \ref{vhdl:latchRemoveEx2}}
	\label{fig:latchRemoveEx2}
\end{figure}
\lstinputlisting[
language = Vhdl,
caption    = {Remove unintentional latch using default values},
label      = {vhdl:latchRemoveEx2}
]{latchRemoveEx2.vhd}
 
\section{Conclusion}
In this chapter, various statements of behavioral modeling styles are discussed. Also, we saw the relationship between the designs generated by behavior modeling and dataflow modeling. Further, problem with loops are discussed and finally loop is implemented using `if' statement. 